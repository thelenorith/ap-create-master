"""
Unit tests for ap_create_master.master_matching module.

Generated By: Cursor (Claude Sonnet 4.5)
"""

from pathlib import Path
from unittest.mock import patch

from ap_create_master import config
from ap_create_master.master_matching import find_matching_master_for_flat


class TestFindMatchingMasterForFlat:
    """Tests for find_matching_master_for_flat function."""

    @patch("ap_common.get_filtered_metadata")
    def test_finds_bias_master(self, mock_get_metadata, tmp_path):
        """Test finding bias master for flat."""
        master_dir = str(tmp_path / "masters")
        Path(master_dir).mkdir(parents=True, exist_ok=True)
        master_file = str(tmp_path / "masters" / "masterBias.xisf")
        flat_headers = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
        }

        # ap-common returns dict with filename as key, metadata as value
        mock_get_metadata.return_value = {
            master_file: {
                config.NORMALIZED_HEADER_TYPE: "MASTER BIAS",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
            }
        }

        result = find_matching_master_for_flat(master_dir, flat_headers, "bias")
        assert result == master_file

    @patch("ap_common.get_filtered_metadata")
    def test_finds_dark_master_with_matching_exposure(
        self, mock_get_metadata, tmp_path
    ):
        """Test finding dark master with matching exposure time."""
        master_dir = str(tmp_path / "masters")
        Path(master_dir).mkdir(parents=True, exist_ok=True)
        master_file = str(tmp_path / "masters" / "masterDark_60s.xisf")
        flat_headers = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
            config.NORMALIZED_HEADER_EXPOSURESECONDS: "60.0",
        }

        mock_get_metadata.return_value = {
            master_file: {
                config.NORMALIZED_HEADER_TYPE: "MASTER DARK",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
                config.NORMALIZED_HEADER_EXPOSURESECONDS: "60.0",
            }
        }

        result = find_matching_master_for_flat(
            master_dir, flat_headers, "dark", flat_exposure_times=[60.0]
        )
        assert result == master_file

    @patch("ap_common.get_filtered_metadata")
    def test_dark_master_prefers_lower_exposure(self, mock_get_metadata, tmp_path):
        """Test that dark master selection prefers lower exposure time."""
        master_dir = str(tmp_path / "masters")
        Path(master_dir).mkdir(parents=True, exist_ok=True)
        master_50s = str(tmp_path / "masters" / "masterDark_50s.xisf")
        master_60s = str(tmp_path / "masters" / "masterDark_60s.xisf")
        master_70s = str(tmp_path / "masters" / "masterDark_70s.xisf")

        flat_headers = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
        }

        # Flat exposure is 60s, should prefer 60s (exact match) over 50s or 70s
        mock_get_metadata.return_value = {
            master_50s: {
                config.NORMALIZED_HEADER_TYPE: "MASTER DARK",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
                config.NORMALIZED_HEADER_EXPOSURESECONDS: "50.0",
            },
            master_60s: {
                config.NORMALIZED_HEADER_TYPE: "MASTER DARK",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
                config.NORMALIZED_HEADER_EXPOSURESECONDS: "60.0",
            },
            master_70s: {
                config.NORMALIZED_HEADER_TYPE: "MASTER DARK",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
                config.NORMALIZED_HEADER_EXPOSURESECONDS: "70.0",
            },
        }

        result = find_matching_master_for_flat(
            master_dir, flat_headers, "dark", flat_exposure_times=[60.0]
        )
        # Should prefer 60s (exact match) over 50s or 70s
        assert result == master_60s

    @patch("ap_common.get_filtered_metadata")
    def test_returns_none_when_no_match(self, mock_get_metadata, tmp_path):
        """Test that function returns None when no matching master found."""
        master_dir = str(tmp_path / "masters")
        flat_headers = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
        }

        mock_get_metadata.return_value = {}  # No matches

        result = find_matching_master_for_flat(master_dir, flat_headers, "bias")
        assert result is None

    def test_returns_none_when_directory_does_not_exist(self, tmp_path):
        """Test that function returns None when master directory doesn't exist."""
        master_dir = str(tmp_path / "nonexistent")
        flat_headers = {}

        result = find_matching_master_for_flat(master_dir, flat_headers, "bias")
        assert result is None

    @patch("ap_common.get_filtered_metadata")
    def test_handles_ap_common_exception(self, mock_get_metadata, tmp_path):
        """Test that function handles exceptions from ap-common gracefully."""
        master_dir = str(tmp_path / "masters")
        flat_headers = {}

        mock_get_metadata.side_effect = Exception("ap-common error")

        result = find_matching_master_for_flat(master_dir, flat_headers, "bias")
        assert result is None

    @patch("ap_common.get_filtered_metadata")
    def test_dark_master_uses_higher_exposure_when_no_lower_available(
        self, mock_get_metadata, tmp_path
    ):
        """Test dark uses closest higher exposure when no lower available."""
        master_dir = str(tmp_path / "masters")
        Path(master_dir).mkdir(parents=True, exist_ok=True)
        master_120s = str(tmp_path / "masters" / "masterDark_120s.xisf")
        master_180s = str(tmp_path / "masters" / "masterDark_180s.xisf")

        flat_headers = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
        }

        # Flat exposure is 60s, but only have 120s and 180s darks
        # Should use 120s (closest higher exposure)
        mock_get_metadata.return_value = {
            master_120s: {
                config.NORMALIZED_HEADER_TYPE: "MASTER DARK",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
                config.NORMALIZED_HEADER_EXPOSURESECONDS: "120.0",
            },
            master_180s: {
                config.NORMALIZED_HEADER_TYPE: "MASTER DARK",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
                config.NORMALIZED_HEADER_EXPOSURESECONDS: "180.0",
            },
        }

        result = find_matching_master_for_flat(
            master_dir, flat_headers, "dark", flat_exposure_times=[60.0]
        )
        # Should use 120s (closest to 60s, even though it's higher)
        assert result == master_120s

    @patch("ap_common.get_filtered_metadata")
    def test_dark_master_handles_missing_exposure_in_headers(
        self, mock_get_metadata, tmp_path
    ):
        """Test that missing exposure time in flat headers falls back to first match."""
        master_dir = str(tmp_path / "masters")
        Path(master_dir).mkdir(parents=True, exist_ok=True)
        master_file = str(tmp_path / "masters" / "masterDark.xisf")

        # Flat headers without exposure time
        flat_headers = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
            # No KEYWORD_EXPOSURESECONDS
        }

        mock_get_metadata.return_value = {
            master_file: {
                config.NORMALIZED_HEADER_TYPE: "MASTER DARK",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
                config.NORMALIZED_HEADER_EXPOSURESECONDS: "60.0",
            }
        }

        # No flat_exposure_times provided, and headers have no exposure
        result = find_matching_master_for_flat(master_dir, flat_headers, "dark")
        # Should return first match when exposure is unavailable
        assert result == master_file

    @patch("ap_common.get_filtered_metadata")
    def test_dark_master_handles_invalid_exposure_in_headers(
        self, mock_get_metadata, tmp_path
    ):
        """Test that invalid exposure time in flat headers falls back to first match."""
        master_dir = str(tmp_path / "masters")
        Path(master_dir).mkdir(parents=True, exist_ok=True)
        master_file = str(tmp_path / "masters" / "masterDark.xisf")

        # Flat headers with non-numeric exposure time
        flat_headers = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
            config.NORMALIZED_HEADER_EXPOSURESECONDS: "not-a-number",  # Invalid
        }

        mock_get_metadata.return_value = {
            master_file: {
                config.NORMALIZED_HEADER_TYPE: "MASTER DARK",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
                config.NORMALIZED_HEADER_EXPOSURESECONDS: "60.0",
            }
        }

        # No flat_exposure_times provided, headers have invalid exposure
        result = find_matching_master_for_flat(master_dir, flat_headers, "dark")
        # Should return first match when exposure can't be parsed
        assert result == master_file

    @patch("ap_common.get_filtered_metadata")
    def test_dark_master_skips_invalid_exposure_in_masters(
        self, mock_get_metadata, tmp_path
    ):
        """Test that dark masters with invalid exposure metadata are skipped."""
        master_dir = str(tmp_path / "masters")
        Path(master_dir).mkdir(parents=True, exist_ok=True)
        master_valid = str(tmp_path / "masters" / "masterDark_valid.xisf")
        master_invalid = str(tmp_path / "masters" / "masterDark_invalid.xisf")

        flat_headers = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
        }

        mock_get_metadata.return_value = {
            master_valid: {
                config.NORMALIZED_HEADER_TYPE: "MASTER DARK",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
                config.NORMALIZED_HEADER_EXPOSURESECONDS: "60.0",  # Valid
            },
            master_invalid: {
                config.NORMALIZED_HEADER_TYPE: "MASTER DARK",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
                # Invalid, should be skipped
                config.NORMALIZED_HEADER_EXPOSURESECONDS: "corrupted",
            },
        }

        result = find_matching_master_for_flat(
            master_dir, flat_headers, "dark", flat_exposure_times=[60.0]
        )
        # Should use the valid master, skip the invalid one
        assert result == master_valid

    @patch("ap_common.get_filtered_metadata")
    def test_dark_master_falls_back_when_all_exposures_invalid(
        self, mock_get_metadata, tmp_path
    ):
        """Test fallback to first match when all exposures invalid."""
        master_dir = str(tmp_path / "masters")
        Path(master_dir).mkdir(parents=True, exist_ok=True)
        master1 = str(tmp_path / "masters" / "masterDark1.xisf")
        master2 = str(tmp_path / "masters" / "masterDark2.xisf")

        flat_headers = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
        }

        # All masters have invalid exposure metadata
        mock_get_metadata.return_value = {
            master1: {
                config.NORMALIZED_HEADER_TYPE: "MASTER DARK",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
                config.NORMALIZED_HEADER_EXPOSURESECONDS: "bad1",  # Invalid
            },
            master2: {
                config.NORMALIZED_HEADER_TYPE: "MASTER DARK",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
                config.NORMALIZED_HEADER_EXPOSURESECONDS: "bad2",  # Invalid
            },
        }

        result = find_matching_master_for_flat(
            master_dir, flat_headers, "dark", flat_exposure_times=[60.0]
        )
        # Should return first match when no valid exposure times found
        assert result in [master1, master2]

    @patch("ap_common.get_filtered_metadata")
    def test_uses_correct_type_filters_for_master_calibration(
        self, mock_get_metadata, tmp_path
    ):
        """Test that correct type filters are used for master calibration frames."""
        master_dir = str(tmp_path / "masters")
        Path(master_dir).mkdir(parents=True, exist_ok=True)
        flat_headers = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
        }

        mock_get_metadata.return_value = {}

        # All types should use "MASTER X" format after ap-create-master writes headers
        find_matching_master_for_flat(master_dir, flat_headers, "bias")
        bias_call = mock_get_metadata.call_args
        assert bias_call.kwargs["filters"]["type"] == "MASTER BIAS"

        find_matching_master_for_flat(master_dir, flat_headers, "dark")
        dark_call = mock_get_metadata.call_args
        assert dark_call.kwargs["filters"]["type"] == "MASTER DARK"

        find_matching_master_for_flat(master_dir, flat_headers, "flat")
        flat_call = mock_get_metadata.call_args
        assert flat_call.kwargs["filters"]["type"] == "MASTER FLAT"
