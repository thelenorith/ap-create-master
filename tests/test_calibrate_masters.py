"""
Unit tests for ap_create_master.calibrate_masters module.

Generated By: Cursor (Claude Sonnet 4.5)
"""

import os
from pathlib import Path
from unittest.mock import patch

import numpy as np
from xisf import XISF

import ap_common
from ap_create_master import config
from ap_create_master.calibrate_masters import (
    generate_masters,
    write_master_imagetyp_headers,
)


class TestGenerateMasters:
    """Tests for generate_masters function."""

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_create_master.calibrate_masters.group_files")
    @patch("ap_create_master.calibrate_masters.get_group_metadata")
    @patch("ap_create_master.calibrate_masters.find_matching_master_for_flat")
    @patch("ap_create_master.calibrate_masters.generate_combined_script")
    def test_generates_script_for_bias_frames(
        self,
        mock_generate_script,
        mock_find_master,
        mock_get_metadata,
        mock_group_files,
        mock_get_filtered,
        tmp_path,
    ):
        """Test that script is generated for bias frames."""
        input_dir = str(tmp_path / "input")
        output_dir = str(tmp_path / "output")
        os.makedirs(input_dir, exist_ok=True)

        bias_headers = {
            config.NORMALIZED_HEADER_TYPE: "bias",
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
        }

        # Mock file discovery
        mock_get_filtered.return_value = {
            "bias1.fits": bias_headers,
            "bias2.fits": bias_headers,
            "bias3.fits": bias_headers,
        }

        # Mock grouping
        mock_group_files.return_value = {
            ("bias", "ATR585M", "-10.00", "239", "150", "Low Conversion Gain"): [
                {"path": "bias1.fits", "headers": bias_headers},
                {"path": "bias2.fits", "headers": bias_headers},
                {"path": "bias3.fits", "headers": bias_headers},
            ]
        }

        # Mock metadata extraction
        mock_get_metadata.return_value = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
        }

        # Mock script generation
        mock_generate_script.return_value = "// Generated script"

        scripts, _ = generate_masters(input_dir, output_dir)

        assert len(scripts) == 1
        assert scripts[0].endswith("calibrate_masters.js")
        mock_generate_script.assert_called_once()

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_create_master.calibrate_masters.group_files")
    @patch("ap_create_master.calibrate_masters.get_group_metadata")
    @patch("ap_create_master.calibrate_masters.find_matching_master_for_flat")
    @patch("ap_create_master.calibrate_masters.generate_combined_script")
    def test_handles_no_files_gracefully(
        self,
        mock_generate_script,
        mock_find_master,
        mock_get_metadata,
        mock_group_files,
        mock_get_filtered,
        tmp_path,
    ):
        """Test that function handles case with no calibration files."""
        input_dir = str(tmp_path / "input")
        output_dir = str(tmp_path / "output")
        os.makedirs(input_dir, exist_ok=True)

        # Mock empty file discovery
        mock_get_filtered.return_value = {}

        scripts, _ = generate_masters(input_dir, output_dir)

        assert scripts == []
        mock_generate_script.assert_not_called()

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_create_master.calibrate_masters.group_files")
    @patch("ap_create_master.calibrate_masters.get_group_metadata")
    @patch("ap_create_master.calibrate_masters.find_matching_master_for_flat")
    @patch("ap_create_master.calibrate_masters.generate_combined_script")
    def test_finds_masters_for_flats(
        self,
        mock_generate_script,
        mock_find_master,
        mock_get_metadata,
        mock_group_files,
        mock_get_filtered,
        tmp_path,
    ):
        """Test that function finds matching masters for flat calibration."""
        input_dir = str(tmp_path / "input")
        output_dir = str(tmp_path / "output")
        bias_master_dir = str(tmp_path / "bias_masters")
        dark_master_dir = str(tmp_path / "dark_masters")
        os.makedirs(input_dir, exist_ok=True)

        flat_headers = {
            config.NORMALIZED_HEADER_TYPE: "flat",
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
            config.NORMALIZED_HEADER_DATE: "2026-01-15",
            config.NORMALIZED_HEADER_FILTER: "B",
            config.NORMALIZED_HEADER_EXPOSURESECONDS: "1.5",
        }

        # Mock flat file discovery
        mock_get_filtered.return_value = {
            "flat1.fits": flat_headers,
            "flat2.fits": flat_headers,
            "flat3.fits": flat_headers,
        }

        # Mock grouping
        mock_group_files.return_value = {
            (
                "flat",
                "ATR585M",
                "-10.00",
                "239",
                "150",
                "Low Conversion Gain",
                "2026-01-15",
                "B",
            ): [
                {"path": "flat1.fits", "headers": flat_headers},
                {"path": "flat2.fits", "headers": flat_headers},
                {"path": "flat3.fits", "headers": flat_headers},
            ]
        }

        # Mock metadata extraction
        mock_get_metadata.return_value = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
            config.NORMALIZED_HEADER_DATE: "2026-01-15",
            config.NORMALIZED_HEADER_FILTER: "B",
        }

        # Mock master finding
        mock_find_master.side_effect = [
            "bias_master.xisf",  # For bias
            "dark_master.xisf",  # For dark
        ]

        # Mock script generation
        mock_generate_script.return_value = "// Generated script"

        scripts, _ = generate_masters(
            input_dir, output_dir, bias_master_dir, dark_master_dir
        )

        assert len(scripts) == 1
        # Should have called find_matching_master_for_flat for both bias and dark
        assert mock_find_master.call_count == 2

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_create_master.calibrate_masters.group_files")
    @patch("ap_create_master.calibrate_masters.get_group_metadata")
    @patch("ap_create_master.calibrate_masters.generate_combined_script")
    def test_uses_custom_script_output_dir(
        self,
        mock_generate_script,
        mock_get_metadata,
        mock_group_files,
        mock_get_filtered,
        tmp_path,
    ):
        """Test that custom script_output_dir is used when provided."""
        input_dir = str(tmp_path / "input")
        output_dir = str(tmp_path / "output")
        custom_script_dir = str(tmp_path / "custom_scripts")
        os.makedirs(input_dir, exist_ok=True)

        bias_headers = {
            config.NORMALIZED_HEADER_TYPE: "bias",
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
        }

        mock_get_filtered.return_value = {
            "bias1.fits": bias_headers,
            "bias2.fits": bias_headers,
            "bias3.fits": bias_headers,
        }

        mock_group_files.return_value = {
            ("bias", "ATR585M", "-10.00", "239", "150", "Low Conversion Gain"): [
                {"path": "bias1.fits", "headers": bias_headers},
                {"path": "bias2.fits", "headers": bias_headers},
                {"path": "bias3.fits", "headers": bias_headers},
            ]
        }

        mock_get_metadata.return_value = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
        }

        mock_generate_script.return_value = "// Generated script"

        scripts, _ = generate_masters(
            input_dir, output_dir, script_output_dir=custom_script_dir
        )

        assert len(scripts) == 1
        # Script should be in custom directory, not default output_dir/scripts
        assert custom_script_dir in scripts[0]
        assert "custom_scripts" in scripts[0]
        # Verify custom directory was created
        assert Path(custom_script_dir).exists()

    @patch("ap_common.get_filtered_metadata")
    def test_handles_ap_common_exception_gracefully(
        self, mock_get_filtered, tmp_path, caplog
    ):
        """Test that exceptions from ap-common are handled gracefully."""
        input_dir = str(tmp_path / "input")
        output_dir = str(tmp_path / "output")
        os.makedirs(input_dir, exist_ok=True)

        # Simulate ap-common failure for one frame type
        def side_effect(*args, **kwargs):
            frame_type = (
                kwargs.get("filters", {}).get(config.NORMALIZED_HEADER_TYPE, "").lower()
            )
            if frame_type == "dark":
                raise PermissionError("Access denied to directory")
            return {}

        mock_get_filtered.side_effect = side_effect

        scripts, _ = generate_masters(input_dir, output_dir)

        # Should still complete successfully, just with no dark files
        assert scripts == []
        # Should log warning about failed discovery
        assert any(
            "Failed to discover dark files" in record.message
            and record.levelname == "WARNING"
            for record in caplog.records
        )

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_create_master.calibrate_masters.group_files")
    @patch("ap_create_master.calibrate_masters.get_group_metadata")
    @patch("ap_create_master.calibrate_masters.find_matching_master_for_flat")
    @patch("ap_create_master.calibrate_masters.generate_combined_script")
    def test_handles_invalid_exposure_time_in_flats(
        self,
        mock_generate_script,
        mock_find_master,
        mock_get_metadata,
        mock_group_files,
        mock_get_filtered,
        tmp_path,
    ):
        """Test that invalid exposure times in flat headers are handled gracefully."""
        input_dir = str(tmp_path / "input")
        output_dir = str(tmp_path / "output")
        dark_master_dir = str(tmp_path / "dark_masters")
        os.makedirs(input_dir, exist_ok=True)

        flat_headers_invalid = {
            config.NORMALIZED_HEADER_TYPE: "flat",
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
            config.NORMALIZED_HEADER_DATE: "2026-01-15",
            config.NORMALIZED_HEADER_FILTER: "B",
            config.NORMALIZED_HEADER_EXPOSURESECONDS: "invalid",  # Non-numeric
        }
        flat_headers_valid = {
            config.NORMALIZED_HEADER_TYPE: "flat",
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
            config.NORMALIZED_HEADER_DATE: "2026-01-15",
            config.NORMALIZED_HEADER_FILTER: "B",
            config.NORMALIZED_HEADER_EXPOSURESECONDS: "1.5",  # Valid
        }

        # Flat with invalid exposure time (non-numeric string)
        mock_get_filtered.return_value = {
            "flat1.fits": flat_headers_invalid,
            "flat2.fits": flat_headers_valid,
            "flat3.fits": flat_headers_valid,
        }

        mock_group_files.return_value = {
            (
                "flat",
                "ATR585M",
                "-10.00",
                "239",
                "150",
                "Low Conversion Gain",
                "2026-01-15",
                "B",
            ): [
                {"path": "flat1.fits", "headers": flat_headers_invalid},
                {"path": "flat2.fits", "headers": flat_headers_valid},
                {"path": "flat3.fits", "headers": flat_headers_valid},
            ]
        }

        mock_get_metadata.return_value = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
            config.NORMALIZED_HEADER_DATE: "2026-01-15",
            config.NORMALIZED_HEADER_FILTER: "B",
        }

        mock_find_master.return_value = "dark_master.xisf"
        mock_generate_script.return_value = "// Generated script"

        scripts, _ = generate_masters(
            input_dir, output_dir, dark_master_dir=dark_master_dir
        )

        # Should still generate script successfully
        assert len(scripts) == 1
        # Should have called find_matching_master_for_flat
        # with valid exposure times (1.5)
        # Invalid exposure should be skipped
        assert mock_find_master.call_count == 1
        call_args = mock_find_master.call_args
        # flat_exposure_times is the 4th positional argument (index 0, 1, 2, 3)
        assert call_args[0][3] == [1.5, 1.5]  # Only valid exposures included

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_create_master.calibrate_masters.group_files")
    @patch("ap_create_master.calibrate_masters.get_group_metadata")
    @patch("ap_create_master.calibrate_masters.generate_combined_script")
    def test_warns_and_skips_group_with_insufficient_images(
        self,
        mock_generate_script,
        mock_get_metadata,
        mock_group_files,
        mock_get_filtered,
        tmp_path,
        caplog,
    ):
        """Test that groups with fewer than 3 images are skipped with a warning."""
        input_dir = str(tmp_path / "input")
        output_dir = str(tmp_path / "output")
        os.makedirs(input_dir, exist_ok=True)

        bias_headers = {
            config.NORMALIZED_HEADER_TYPE: "bias",
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
        }

        # Only 1 bias file in group
        mock_get_filtered.return_value = {"bias1.fits": bias_headers}

        mock_group_files.return_value = {
            ("bias", "ATR585M", "-10.00", "239", "150", "Low Conversion Gain"): [
                {"path": "bias1.fits", "headers": bias_headers},
            ]
        }

        mock_get_metadata.return_value = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
        }

        mock_generate_script.return_value = "// Generated script"

        scripts, _ = generate_masters(input_dir, output_dir)

        # Group should be skipped, no script generated
        assert scripts == []
        mock_generate_script.assert_not_called()

        # Should log a warning about insufficient images
        assert any(
            "Skipping bias group" in record.message
            and "has 1 image(s)" in record.message
            and "need at least 3" in record.message
            and record.levelname == "WARNING"
            for record in caplog.records
        )

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_create_master.calibrate_masters.group_files")
    @patch("ap_create_master.calibrate_masters.get_group_metadata")
    @patch("ap_create_master.calibrate_masters.generate_combined_script")
    def test_skips_insufficient_group_but_keeps_valid_groups(
        self,
        mock_generate_script,
        mock_get_metadata,
        mock_group_files,
        mock_get_filtered,
        tmp_path,
        caplog,
    ):
        """Test that only insufficient groups are skipped; valid groups proceed."""
        input_dir = str(tmp_path / "input")
        output_dir = str(tmp_path / "output")
        os.makedirs(input_dir, exist_ok=True)

        bias_headers_a = {
            config.NORMALIZED_HEADER_TYPE: "bias",
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
        }
        bias_headers_b = {
            config.NORMALIZED_HEADER_TYPE: "bias",
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-20.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
        }

        # Return bias files only for BIAS type, empty for others
        def get_filtered_side_effect(*args, **kwargs):
            frame_type = kwargs.get("filters", {}).get(
                config.NORMALIZED_HEADER_TYPE, ""
            )
            if frame_type == "BIAS":
                return {
                    "bias_a1.fits": bias_headers_a,
                    "bias_b1.fits": bias_headers_b,
                    "bias_b2.fits": bias_headers_b,
                    "bias_b3.fits": bias_headers_b,
                }
            return {}

        mock_get_filtered.side_effect = get_filtered_side_effect

        # Two groups: group A has 1 file (skip), group B has 3 files (keep)
        mock_group_files.return_value = {
            ("bias", "ATR585M", "-10.00", "239", "150", "Low Conversion Gain"): [
                {"path": "bias_a1.fits", "headers": bias_headers_a},
            ],
            ("bias", "ATR585M", "-20.00", "239", "150", "Low Conversion Gain"): [
                {"path": "bias_b1.fits", "headers": bias_headers_b},
                {"path": "bias_b2.fits", "headers": bias_headers_b},
                {"path": "bias_b3.fits", "headers": bias_headers_b},
            ],
        }

        mock_get_metadata.side_effect = [
            {
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
            },
            {
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-20.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
            },
        ]

        mock_generate_script.return_value = "// Generated script"

        scripts, _ = generate_masters(input_dir, output_dir)

        # Valid group should still generate a script
        assert len(scripts) == 1
        mock_generate_script.assert_called_once()

        # Should have only 1 bias group (the one with 3 files)
        call_args = mock_generate_script.call_args
        assert len(call_args[0][1]) == 1  # Only 1 bias group passed

        # Should log a warning for the skipped group
        assert any(
            "Skipping bias group" in record.message
            and record.levelname == "WARNING"
            for record in caplog.records
        )


class TestWriteMasterImagetypHeaders:
    """Tests for write_master_imagetyp_headers function."""

    def test_writes_imagetyp_header_for_bias(self, tmp_path):
        """Test that IMAGETYP header is written correctly for bias masters."""
        # Create a test XISF file
        master_file = tmp_path / "masterBias.xisf"
        image_data = np.zeros((10, 10, 1), dtype=np.float32)
        XISF.write(str(master_file), image_data)

        # Write headers
        write_master_imagetyp_headers([(str(master_file), "bias")])

        # Read back and verify
        image_metadata = {}
        XISF.read(str(master_file), image_metadata=image_metadata)

        # Verify IMAGETYP header was written
        assert "FITSKeywords" in image_metadata

        # Get denormalized header key (should be "IMAGETYP")
        header_key = ap_common.denormalize_header(config.NORMALIZED_HEADER_TYPE)
        assert (
            header_key == "IMAGETYP"
        ), "denormalize_header('type') must return 'IMAGETYP'"

        assert header_key in image_metadata["FITSKeywords"]
        assert image_metadata["FITSKeywords"][header_key][0]["value"] == "MASTER BIAS"

    def test_writes_imagetyp_header_for_dark(self, tmp_path):
        """Test that IMAGETYP header is written correctly for dark masters."""
        master_file = tmp_path / "masterDark.xisf"
        image_data = np.zeros((10, 10, 1), dtype=np.float32)
        XISF.write(str(master_file), image_data)

        write_master_imagetyp_headers([(str(master_file), "dark")])

        image_metadata = {}
        XISF.read(str(master_file), image_metadata=image_metadata)

        header_key = ap_common.denormalize_header(config.NORMALIZED_HEADER_TYPE)
        assert header_key in image_metadata["FITSKeywords"]
        assert image_metadata["FITSKeywords"][header_key][0]["value"] == "MASTER DARK"

    def test_writes_imagetyp_header_for_flat(self, tmp_path):
        """Test that IMAGETYP header is written correctly for flat masters."""
        master_file = tmp_path / "masterFlat.xisf"
        image_data = np.zeros((10, 10, 1), dtype=np.float32)
        XISF.write(str(master_file), image_data)

        write_master_imagetyp_headers([(str(master_file), "flat")])

        image_metadata = {}
        XISF.read(str(master_file), image_metadata=image_metadata)

        header_key = ap_common.denormalize_header(config.NORMALIZED_HEADER_TYPE)
        assert header_key in image_metadata["FITSKeywords"]
        assert image_metadata["FITSKeywords"][header_key][0]["value"] == "MASTER FLAT"

    def test_critical_denormalization_check(self):
        """CRITICAL: Verify that denormalizing 'type' returns 'IMAGETYP'.

        This test ensures that the normalization mapping is correct.
        If this test fails, the IMAGETYP header writing logic needs review.
        """
        header_key = ap_common.denormalize_header(config.NORMALIZED_HEADER_TYPE)
        assert header_key == "IMAGETYP", (
            f"CRITICAL: denormalize_header('{config.NORMALIZED_HEADER_TYPE}') "
            f"must return 'IMAGETYP', got '{header_key}'. "
            "This breaks master calibration frame header writing."
        )

    def test_handles_multiple_files(self, tmp_path):
        """Test that multiple files can be processed in one call."""
        bias_file = tmp_path / "masterBias.xisf"
        dark_file = tmp_path / "masterDark.xisf"
        flat_file = tmp_path / "masterFlat.xisf"

        for f in [bias_file, dark_file, flat_file]:
            image_data = np.zeros((10, 10, 1), dtype=np.float32)
            XISF.write(str(f), image_data)

        write_master_imagetyp_headers(
            [
                (str(bias_file), "bias"),
                (str(dark_file), "dark"),
                (str(flat_file), "flat"),
            ]
        )

        # Verify all files were updated
        header_key = ap_common.denormalize_header(config.NORMALIZED_HEADER_TYPE)

        for file_path, expected_type in [
            (bias_file, "MASTER BIAS"),
            (dark_file, "MASTER DARK"),
            (flat_file, "MASTER FLAT"),
        ]:
            image_metadata = {}
            XISF.read(str(file_path), image_metadata=image_metadata)
            assert (
                image_metadata["FITSKeywords"][header_key][0]["value"] == expected_type
            )

    def test_handles_missing_file_gracefully(self, tmp_path, caplog):
        """Test that missing files are handled gracefully with a warning."""
        nonexistent_file = tmp_path / "nonexistent.xisf"

        write_master_imagetyp_headers([(str(nonexistent_file), "bias")])

        # Should log a warning, not crash
        assert "not found" in caplog.text.lower()

    def test_handles_unknown_frame_type_gracefully(self, tmp_path, caplog):
        """Test that unknown frame types are handled gracefully with a warning."""
        master_file = tmp_path / "masterUnknown.xisf"
        image_data = np.zeros((10, 10, 1), dtype=np.float32)
        XISF.write(str(master_file), image_data)

        write_master_imagetyp_headers([(str(master_file), "unknown")])

        # Should log a warning about unknown frame type
        assert "unknown" in caplog.text.lower()

    def test_preserves_existing_headers(self, tmp_path):
        """Test that existing headers are preserved when writing IMAGETYP."""
        master_file = tmp_path / "masterBias.xisf"
        image_data = np.zeros((10, 10, 1), dtype=np.float32)

        # Write with existing headers
        existing_metadata = {
            "FITSKeywords": {
                "CAMERA": [{"value": "ATR585M", "comment": "Test camera"}],
                "GAIN": [{"value": "239", "comment": "Test gain"}],
            }
        }
        XISF.write(str(master_file), image_data, image_metadata=existing_metadata)

        # Write IMAGETYP header
        write_master_imagetyp_headers([(str(master_file), "bias")])

        # Read back and verify both headers exist
        image_metadata = {}
        XISF.read(str(master_file), image_metadata=image_metadata)

        header_key = ap_common.denormalize_header(config.NORMALIZED_HEADER_TYPE)
        assert image_metadata["FITSKeywords"][header_key][0]["value"] == "MASTER BIAS"
        assert image_metadata["FITSKeywords"]["CAMERA"][0]["value"] == "ATR585M"
        assert image_metadata["FITSKeywords"]["GAIN"][0]["value"] == "239"

    def test_adds_comment_to_imagetyp_header(self, tmp_path):
        """Test that IMAGETYP header includes a descriptive comment."""
        master_file = tmp_path / "masterBias.xisf"
        image_data = np.zeros((10, 10, 1), dtype=np.float32)
        XISF.write(str(master_file), image_data)

        write_master_imagetyp_headers([(str(master_file), "bias")])

        image_metadata = {}
        XISF.read(str(master_file), image_metadata=image_metadata)

        header_key = ap_common.denormalize_header(config.NORMALIZED_HEADER_TYPE)
        comment = image_metadata["FITSKeywords"][header_key][0]["comment"]
        assert "master" in comment.lower() or "calibration" in comment.lower()
