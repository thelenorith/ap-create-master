"""
Unit tests for ap_create_master.calibrate_masters module.

Generated By: Cursor (Claude Sonnet 4.5)
"""

import os
from pathlib import Path
from unittest.mock import patch

import pytest

from ap_create_master import config
from ap_create_master.calibrate_masters import generate_masters


class TestGenerateMasters:
    """Tests for generate_masters function."""

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_create_master.calibrate_masters.group_files")
    @patch("ap_create_master.calibrate_masters.get_group_metadata")
    @patch("ap_create_master.calibrate_masters.find_matching_master_for_flat")
    @patch("ap_create_master.calibrate_masters.generate_combined_script")
    def test_generates_script_for_bias_frames(
        self,
        mock_generate_script,
        mock_find_master,
        mock_get_metadata,
        mock_group_files,
        mock_get_filtered,
        tmp_path,
    ):
        """Test that script is generated for bias frames."""
        input_dir = str(tmp_path / "input")
        output_dir = str(tmp_path / "output")
        os.makedirs(input_dir, exist_ok=True)

        # Mock file discovery
        mock_get_filtered.return_value = {
            "bias1.fits": {
                config.NORMALIZED_HEADER_TYPE: "bias",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
            },
            "bias2.fits": {
                config.NORMALIZED_HEADER_TYPE: "bias",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
            },
        }

        # Mock grouping
        mock_group_files.return_value = {
            ("bias", "ATR585M", "-10.00", "239", "150", "Low Conversion Gain"): [
                {
                    "path": "bias1.fits",
                    "headers": mock_get_filtered.return_value["bias1.fits"],
                },
                {
                    "path": "bias2.fits",
                    "headers": mock_get_filtered.return_value["bias2.fits"],
                },
            ]
        }

        # Mock metadata extraction
        mock_get_metadata.return_value = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
        }

        # Mock script generation
        mock_generate_script.return_value = "// Generated script"

        scripts = generate_masters(input_dir, output_dir)

        assert len(scripts) == 1
        assert scripts[0].endswith("calibrate_masters.js")
        mock_generate_script.assert_called_once()

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_create_master.calibrate_masters.group_files")
    @patch("ap_create_master.calibrate_masters.get_group_metadata")
    @patch("ap_create_master.calibrate_masters.find_matching_master_for_flat")
    @patch("ap_create_master.calibrate_masters.generate_combined_script")
    def test_handles_no_files_gracefully(
        self,
        mock_generate_script,
        mock_find_master,
        mock_get_metadata,
        mock_group_files,
        mock_get_filtered,
        tmp_path,
    ):
        """Test that function handles case with no calibration files."""
        input_dir = str(tmp_path / "input")
        output_dir = str(tmp_path / "output")
        os.makedirs(input_dir, exist_ok=True)

        # Mock empty file discovery
        mock_get_filtered.return_value = {}

        scripts = generate_masters(input_dir, output_dir)

        assert scripts == []
        mock_generate_script.assert_not_called()

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_create_master.calibrate_masters.group_files")
    @patch("ap_create_master.calibrate_masters.get_group_metadata")
    @patch("ap_create_master.calibrate_masters.find_matching_master_for_flat")
    @patch("ap_create_master.calibrate_masters.generate_combined_script")
    def test_finds_masters_for_flats(
        self,
        mock_generate_script,
        mock_find_master,
        mock_get_metadata,
        mock_group_files,
        mock_get_filtered,
        tmp_path,
    ):
        """Test that function finds matching masters for flat calibration."""
        input_dir = str(tmp_path / "input")
        output_dir = str(tmp_path / "output")
        bias_master_dir = str(tmp_path / "bias_masters")
        dark_master_dir = str(tmp_path / "dark_masters")
        os.makedirs(input_dir, exist_ok=True)

        # Mock flat file discovery
        mock_get_filtered.return_value = {
            "flat1.fits": {
                config.NORMALIZED_HEADER_TYPE: "flat",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
                config.NORMALIZED_HEADER_DATE: "2026-01-15",
                config.NORMALIZED_HEADER_FILTER: "B",
                config.NORMALIZED_HEADER_EXPOSURESECONDS: "1.5",
            }
        }

        # Mock grouping
        mock_group_files.return_value = {
            (
                "flat",
                "ATR585M",
                "-10.00",
                "239",
                "150",
                "Low Conversion Gain",
                "2026-01-15",
                "B",
            ): [
                {
                    "path": "flat1.fits",
                    "headers": mock_get_filtered.return_value["flat1.fits"],
                }
            ]
        }

        # Mock metadata extraction
        mock_get_metadata.return_value = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
            config.NORMALIZED_HEADER_DATE: "2026-01-15",
            config.NORMALIZED_HEADER_FILTER: "B",
        }

        # Mock master finding
        mock_find_master.side_effect = [
            "bias_master.xisf",  # For bias
            "dark_master.xisf",  # For dark
        ]

        # Mock script generation
        mock_generate_script.return_value = "// Generated script"

        scripts = generate_masters(
            input_dir, output_dir, bias_master_dir, dark_master_dir
        )

        assert len(scripts) == 1
        # Should have called find_matching_master_for_flat for both bias and dark
        assert mock_find_master.call_count == 2

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_create_master.calibrate_masters.group_files")
    @patch("ap_create_master.calibrate_masters.get_group_metadata")
    @patch("ap_create_master.calibrate_masters.generate_combined_script")
    def test_uses_custom_script_output_dir(
        self,
        mock_generate_script,
        mock_get_metadata,
        mock_group_files,
        mock_get_filtered,
        tmp_path,
    ):
        """Test that custom script_output_dir is used when provided."""
        input_dir = str(tmp_path / "input")
        output_dir = str(tmp_path / "output")
        custom_script_dir = str(tmp_path / "custom_scripts")
        os.makedirs(input_dir, exist_ok=True)

        mock_get_filtered.return_value = {
            "bias1.fits": {
                config.NORMALIZED_HEADER_TYPE: "bias",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
            }
        }

        mock_group_files.return_value = {
            ("bias", "ATR585M", "-10.00", "239", "150", "Low Conversion Gain"): [
                {
                    "path": "bias1.fits",
                    "headers": mock_get_filtered.return_value["bias1.fits"],
                }
            ]
        }

        mock_get_metadata.return_value = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
        }

        mock_generate_script.return_value = "// Generated script"

        scripts = generate_masters(
            input_dir, output_dir, script_output_dir=custom_script_dir
        )

        assert len(scripts) == 1
        # Script should be in custom directory, not default output_dir/scripts
        assert custom_script_dir in scripts[0]
        assert "custom_scripts" in scripts[0]
        # Verify custom directory was created
        assert Path(custom_script_dir).exists()

    @patch("ap_common.get_filtered_metadata")
    def test_handles_ap_common_exception_gracefully(
        self, mock_get_filtered, tmp_path, capsys
    ):
        """Test that exceptions from ap-common are handled gracefully."""
        input_dir = str(tmp_path / "input")
        output_dir = str(tmp_path / "output")
        os.makedirs(input_dir, exist_ok=True)

        # Simulate ap-common failure for one frame type
        def side_effect(*args, **kwargs):
            frame_type = (
                kwargs.get("filters", {}).get(config.NORMALIZED_HEADER_TYPE, "").lower()
            )
            if frame_type == "dark":
                raise PermissionError("Access denied to directory")
            return {}

        mock_get_filtered.side_effect = side_effect

        scripts = generate_masters(input_dir, output_dir)

        # Should still complete successfully, just with no dark files
        assert scripts == []
        # Should print warning about failed discovery
        captured = capsys.readouterr()
        assert "Warning" in captured.out
        assert "dark" in captured.out.lower()

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_create_master.calibrate_masters.group_files")
    @patch("ap_create_master.calibrate_masters.get_group_metadata")
    @patch("ap_create_master.calibrate_masters.find_matching_master_for_flat")
    @patch("ap_create_master.calibrate_masters.generate_combined_script")
    def test_handles_invalid_exposure_time_in_flats(
        self,
        mock_generate_script,
        mock_find_master,
        mock_get_metadata,
        mock_group_files,
        mock_get_filtered,
        tmp_path,
    ):
        """Test that invalid exposure times in flat headers are handled gracefully."""
        input_dir = str(tmp_path / "input")
        output_dir = str(tmp_path / "output")
        dark_master_dir = str(tmp_path / "dark_masters")
        os.makedirs(input_dir, exist_ok=True)

        # Flat with invalid exposure time (non-numeric string)
        mock_get_filtered.return_value = {
            "flat1.fits": {
                config.NORMALIZED_HEADER_TYPE: "flat",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
                config.NORMALIZED_HEADER_DATE: "2026-01-15",
                config.NORMALIZED_HEADER_FILTER: "B",
                config.NORMALIZED_HEADER_EXPOSURESECONDS: "invalid",  # Non-numeric
            },
            "flat2.fits": {
                config.NORMALIZED_HEADER_TYPE: "flat",
                config.NORMALIZED_HEADER_CAMERA: "ATR585M",
                config.NORMALIZED_HEADER_SETTEMP: "-10.00",
                config.NORMALIZED_HEADER_GAIN: "239",
                config.NORMALIZED_HEADER_OFFSET: "150",
                config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
                config.NORMALIZED_HEADER_DATE: "2026-01-15",
                config.NORMALIZED_HEADER_FILTER: "B",
                config.NORMALIZED_HEADER_EXPOSURESECONDS: "1.5",  # Valid
            },
        }

        mock_group_files.return_value = {
            (
                "flat",
                "ATR585M",
                "-10.00",
                "239",
                "150",
                "Low Conversion Gain",
                "2026-01-15",
                "B",
            ): [
                {
                    "path": "flat1.fits",
                    "headers": mock_get_filtered.return_value["flat1.fits"],
                },
                {
                    "path": "flat2.fits",
                    "headers": mock_get_filtered.return_value["flat2.fits"],
                },
            ]
        }

        mock_get_metadata.return_value = {
            config.NORMALIZED_HEADER_CAMERA: "ATR585M",
            config.NORMALIZED_HEADER_SETTEMP: "-10.00",
            config.NORMALIZED_HEADER_GAIN: "239",
            config.NORMALIZED_HEADER_OFFSET: "150",
            config.NORMALIZED_HEADER_READOUTMODE: "Low Conversion Gain",
            config.NORMALIZED_HEADER_DATE: "2026-01-15",
            config.NORMALIZED_HEADER_FILTER: "B",
        }

        mock_find_master.return_value = "dark_master.xisf"
        mock_generate_script.return_value = "// Generated script"

        scripts = generate_masters(
            input_dir, output_dir, dark_master_dir=dark_master_dir
        )

        # Should still generate script successfully
        assert len(scripts) == 1
        # Should have called find_matching_master_for_flat with valid exposure time (1.5)
        # Invalid exposure should be skipped
        assert mock_find_master.call_count == 1
        call_args = mock_find_master.call_args
        # flat_exposure_times is the 4th positional argument (index 0, 1, 2, 3)
        assert call_args[0][3] == [1.5]  # Only valid exposure included
