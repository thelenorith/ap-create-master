"""
Generated By: Cursor (Claude Sonnet 4.5)

Generate PixInsight JavaScript scripts for calibration master generation.
"""

from pathlib import Path
from typing import Dict, List, Optional, Tuple

import ap_common
from jinja2 import Environment, FileSystemLoader, select_autoescape

from . import config


def escape_js_string(path: str) -> str:
    """Escape a file path for use in JavaScript string literal."""
    # Replace backslashes with forward slashes (PixInsight accepts both)
    # and escape any quotes
    path = path.replace("\\", "/")
    path = path.replace('"', '\\"')
    return path


def _get_template_env() -> Environment:
    """Get Jinja2 template environment with custom filters."""
    template_dir = Path(__file__).parent / "templates"
    env = Environment(
        loader=FileSystemLoader(str(template_dir)),
        autoescape=select_autoescape([]),  # No auto-escaping for JS
    )
    env.filters["escape_js"] = escape_js_string
    return env


def generate_master_filename(metadata: Dict[str, str], frame_type: str) -> str:
    """
    Generate master filename based on metadata.

    Uses required keywords from config, excluding TYPE.
    First part is frame type capitalized + "master" lowercase.

    Args:
        metadata: Dictionary of keyword values
        frame_type: "bias", "dark", or "flat"

    Returns:
        Filename string (without extension)
    """
    if frame_type not in config.REQUIRED_KEYWORDS:
        raise ValueError(f"Unknown frame type: {frame_type}")

    # First part: frame type capitalized + "master" lowercase
    frame_type_cap = frame_type.capitalize()
    parts = [f"master{frame_type_cap}"]

    # Add parts from required keywords (excluding TYPE)
    required = config.REQUIRED_KEYWORDS[frame_type]
    for keyword in required:
        if keyword == config.NORMALIZED_HEADER_TYPE:
            continue  # Skip TYPE keyword

        value = metadata.get(keyword, "UNKNOWN")

        # Denormalize keyword name back to FITS form for filename
        # ap-common can convert normalized keywords back to original FITS names
        denormalized = ap_common.denormalize_header(keyword)
        if denormalized:
            keyword_safe = denormalized
        else:
            # Fallback: uppercase the normalized keyword
            keyword_safe = keyword.upper()
        parts.append(f"{keyword_safe}_{value}")

    # Sanitize filename parts (replace invalid chars)
    sanitized = []
    for part in parts:
        # Replace invalid filename characters
        part = part.replace(":", "-")
        part = part.replace("/", "-")
        part = part.replace("\\", "-")
        sanitized.append(part)

    return "_".join(sanitized)


def generate_combined_script(
    master_output_dir: str,
    bias_groups: List[Tuple[Dict[str, str], List[str]]],
    dark_groups: List[Tuple[Dict[str, str], List[str]]],
    flat_groups: List[Tuple[Dict[str, str], List[str], Optional[str], Optional[str]]],
    log_file: str,
    calibrated_base_dir: Optional[str] = None,
) -> str:
    """
    Generate a single combined script that processes all groups sequentially.

    Args:
        master_output_dir: Output directory for master files
        bias_groups: List of (metadata, file_paths) tuples for bias groups
        dark_groups: List of (metadata, file_paths) tuples for dark groups
        flat_groups: List of (metadata, file_paths, master_bias_xisf, master_dark_xisf) tuples for flat groups
        log_file: Path to log file for Console.beginLog()
        calibrated_base_dir: Base directory for calibrated flat frames (default: same as master_output_dir)

    Returns:
        Combined JavaScript code as string
    """
    env = _get_template_env()
    template = env.get_template("combined.j2")

    output_path = Path(master_output_dir)
    calibrated_path = Path(calibrated_base_dir) if calibrated_base_dir else output_path

    # Prepare template context for bias groups
    bias_contexts = []
    for metadata, file_paths in bias_groups:
        master_name = generate_master_filename(metadata, "bias")
        output_file = output_path / f"{master_name}.xisf"
        bias_contexts.append(
            {
                "file_paths": [escape_js_string(p) for p in file_paths],
                "master_name": master_name,
                "output_path": escape_js_string(str(output_file)),
            }
        )

    # Prepare template context for dark groups
    dark_contexts = []
    for metadata, file_paths in dark_groups:
        master_name = generate_master_filename(metadata, "dark")
        output_file = output_path / f"{master_name}.xisf"
        dark_contexts.append(
            {
                "file_paths": [escape_js_string(p) for p in file_paths],
                "master_name": master_name,
                "output_path": escape_js_string(str(output_file)),
            }
        )

    # Prepare template context for flat groups
    flat_contexts = []
    for metadata, file_paths, master_bias_xisf, master_dark_xisf in flat_groups:
        master_name = generate_master_filename(metadata, "flat")
        calibrated_dir = calibrated_path / "calibrated" / master_name
        master_output_path = output_path / f"{master_name}.xisf"

        # Generate expected calibrated file paths
        # ImageCalibration creates: <input_basename>_c.xisf in calibrated_dir
        calibrated_file_paths = []
        if master_bias_xisf or master_dark_xisf:
            for file_path in file_paths:
                file_stem = Path(file_path).stem  # filename without extension
                calibrated_file = calibrated_dir / f"{file_stem}_c.xisf"
                calibrated_file_paths.append(str(calibrated_file))

        flat_contexts.append(
            {
                "file_paths": [escape_js_string(p) for p in file_paths],
                "master_name": master_name,
                "calibrated_dir": escape_js_string(str(calibrated_dir)),
                "calibrated_file_paths": [
                    escape_js_string(p) for p in calibrated_file_paths
                ],
                "output_path": escape_js_string(str(master_output_path)),
                "master_bias_path": (
                    escape_js_string(master_bias_xisf) if master_bias_xisf else ""
                ),
                "master_dark_path": (
                    escape_js_string(master_dark_xisf) if master_dark_xisf else ""
                ),
                "master_bias_enabled": master_bias_xisf is not None,
                "master_dark_enabled": master_dark_xisf is not None,
            }
        )

    return template.render(
        bias_groups=bias_contexts,
        dark_groups=dark_contexts,
        flat_groups=flat_contexts,
        log_file=escape_js_string(log_file),
    )
