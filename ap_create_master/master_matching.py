"""
Generated By: Cursor (Claude Sonnet 4.5)

Find matching bias/dark masters for flat calibration.
"""

import logging
import ap_common
from ap_common.metadata import build_normalized_filters
from pathlib import Path
from typing import Any, Dict, List, Optional, TypedDict

from . import config

logger = logging.getLogger(__name__)


class DarkCandidate(TypedDict):
    """Type definition for dark candidate dictionary."""

    path: str
    exposure: float


def find_matching_master_for_flat(
    master_dir: str,
    flat_headers: Dict,
    master_type: str,
    flat_exposure_times: Optional[List[float]] = None,
) -> Optional[str]:
    """
    Find a matching master file for flat calibration.

    For bias: Matches on instrument settings only (MASTER_MATCH_KEYWORDS).
    For dark: Matches on instrument settings, then selects dark with exposure time
    closest to (but preferably less than) the flat's exposure time.

    Args:
        master_dir: Directory containing master files
        flat_headers: FITS headers from a flat frame (or representative flat from group)
        master_type: "bias" or "dark"
        flat_exposure_times: List of exposure times for all
            flats in the group (for dark matching)
                             If None, uses EXPOSURE/EXPTIME from flat_headers

    Returns:
        Path to matching master file, or None if not found
    """
    logger.debug(f"Searching for {master_type} master in: {master_dir}")

    master_path = Path(master_dir)
    if not master_path.exists():
        logger.debug(f"Master directory does not exist: {master_dir}")
        return None

    # Build filters dict: TYPE and all instrument settings
    # TYPE format: "MASTER BIAS", "MASTER DARK", "MASTER FLAT"
    # These are written by ap-create-master after PixInsight generates masters
    type_value = f"MASTER {master_type.upper()}"
    filters = build_normalized_filters(
        flat_headers,
        config.MASTER_MATCH_KEYWORDS,
        overrides={config.NORMALIZED_HEADER_TYPE: type_value},
    )

    logger.debug(f"Filters: {filters}")

    # Build required_properties list
    # (TYPE + instrument settings + EXPOSURESECONDS for darks)
    required_properties = [config.NORMALIZED_HEADER_TYPE] + list(
        config.MASTER_MATCH_KEYWORDS
    )
    if master_type == "dark":
        required_properties.append(config.NORMALIZED_HEADER_EXPOSURESECONDS)

    # Get filtered metadata using ap-common
    try:
        matching_masters = ap_common.get_filtered_metadata(
            dirs=[str(master_path)],
            filters=filters,
            profileFromPath=False,
            patterns=[r".*\.xisf$", r".*\.fits$"],
            recursive=True,
            required_properties=required_properties,
            debug=False,
            printStatus=False,
        )
    except Exception as e:
        # If ap-common can't process the directory, we're done
        logger.debug(f"Error scanning directory: {e}")
        return None

    logger.debug(f"Found {len(matching_masters)} matching {master_type} master(s)")

    if not matching_masters:
        logger.debug(f"No matching {master_type} master found")
        return None

    # For bias, return first match (all should be equivalent)
    if master_type == "bias":
        return next(iter(matching_masters.keys()))

    # For dark, need to match exposure time
    if master_type == "dark":
        return _find_best_dark_match(
            matching_masters, flat_headers, flat_exposure_times
        )

    return None


def _find_best_dark_match(
    matching_masters: Dict[str, Dict],
    flat_headers: Dict,
    flat_exposure_times: Optional[List[float]] = None,
) -> Optional[str]:
    """
    Find the best matching dark master based on exposure time.

    Prefers darks with exposure time less than or equal to the flat's exposure time.
    If no such dark exists, uses the closest dark with higher exposure time.

    Args:
        matching_masters: Dict mapping filename to metadata dict
        flat_headers: FITS headers from flat frame
        flat_exposure_times: List of exposure times for all flats in group (optional)

    Returns:
        Path to best matching dark master, or None if no valid exposure time found
    """
    # Determine target exposure time
    if flat_exposure_times:
        # Use minimum exposure time from the group (prefer scaling up)
        target_exposure = min(flat_exposure_times)
        logger.debug(
            f"Target exposure: {target_exposure}s "
            f"(min of flat group: {flat_exposure_times})"
        )
    else:
        # Use exposure from headers
        target_exposure_raw: Any = flat_headers.get(
            config.NORMALIZED_HEADER_EXPOSURESECONDS
        )
        if target_exposure_raw is None:
            # No exposure time available, return first match
            logger.debug("No exposure time in flat headers, using first match")
            return next(iter(matching_masters.keys()))
        try:
            target_exposure = float(target_exposure_raw)
            logger.debug(f"Target exposure: {target_exposure}s (from flat headers)")
        except (ValueError, TypeError):
            # Can't parse exposure time, return first match
            logger.debug("Cannot parse exposure time, using first match")
            return next(iter(matching_masters.keys()))

    # Extract exposure times from masters
    dark_candidates: list[DarkCandidate] = []
    for filename, metadata in matching_masters.items():
        exposure = metadata.get(config.NORMALIZED_HEADER_EXPOSURESECONDS)
        if exposure is None:
            continue
        try:
            exposure_float = float(exposure)
            dark_candidates.append(
                DarkCandidate(path=filename, exposure=exposure_float)
            )
        except (ValueError, TypeError):
            continue

    if not dark_candidates:
        # No valid exposure times, return first match
        logger.debug("No valid dark exposure times found, using first match")
        return next(iter(matching_masters.keys()))

    exposures_str = ", ".join([f"{d['exposure']}s" for d in dark_candidates])
    logger.debug(f"Dark candidates with exposures: {exposures_str}")

    # Prefer darks with exposure <= target (scaling up is better)
    # If none exist, use the closest dark with higher exposure
    suitable_darks = [d for d in dark_candidates if d["exposure"] <= target_exposure]

    if suitable_darks:
        # Find the one closest to target (prefer higher values, but still <= target)
        best_dark = max(suitable_darks, key=lambda d: d["exposure"])
        logger.debug(f"Selected dark with {best_dark['exposure']}s (closest <= target)")
        logger.debug(f"Using: {Path(best_dark['path']).name}")
        return best_dark["path"]
    else:
        # No dark with exposure <= target, use closest higher exposure
        best_dark = min(
            dark_candidates, key=lambda d: abs(d["exposure"] - target_exposure)
        )
        logger.debug(
            f"Selected dark with {best_dark['exposure']}s "
            f"(closest > target, will scale down)"
        )
        logger.debug(f"Using: {Path(best_dark['path']).name}")
        return best_dark["path"]
